import { create } from "zustand";
import { 
  Node, 
  Edge, 
  Connection, 
  addEdge, 
  OnNodesChange, 
  OnEdgesChange,
  OnConnect,
  applyNodeChanges,
  applyEdgeChanges
} from "@xyflow/react";
import { v4 as uuidv4 } from "uuid";

export type NodeData = {
  label: string;
  type: string;
  config: Record<string, unknown>;
};

interface GraphState {
  nodes: Node<NodeData>[];
  edges: Edge[];
  selectedNode: string | null;
  
  addNode: (type: string, position: { x: number; y: number }, config?: Record<string, unknown>, options?: { selectNode?: boolean }) => void;
  addNodesWithEdges: (nodes: Array<{ type: string; position: { x: number; y: number }; config?: Record<string, unknown> }>, edges?: Array<{ source: number; target: number }>) => void;
  addOutputNode: () => void;
  updateNodeConfig: (nodeId: string, config: Record<string, unknown>) => void;
  updateNodeType: (nodeId: string, type: string, config?: Record<string, unknown>) => void;
  deleteNode: (nodeId: string) => void;
  selectNode: (nodeId: string | null) => void;
  clearAll: () => void;
  
  onNodesChange: OnNodesChange<Node<NodeData>>;
  onEdgesChange: OnEdgesChange<Edge>;
  onConnect: OnConnect;
}

export const nodeDefaults: Record<string, Partial<NodeData>> = {
  pipeline: {
    label: "Pipeline",
    config: {
      pipelineId: "",
      pipelineName: "",
      remoteInference: false,
    },
  },
  videoInput: {
    label: "Video Input",
    config: {},
  },
  textPrompt: {
    label: "Text Prompt",
    config: { text: "", weight: 1.0 },
  },
  imageInput: {
    label: "Image Input",
    config: { path: "" },
  },
  parameters: {
    label: "Parameters",
    config: {},
  },
  custom: {
    label: "Custom Processor",
    config: { 
      name: "My Processor",
      params: [],
      code: "",
      isCodeMode: true,
    },
  },
  pipelineOutput: {
    label: "Pipeline Output",
    config: { usage: "main" },
  },
  pluginConfig: {
    label: "Plugin Configuration",
    config: {
      pipelineId: "",
      pipelineName: "My Plugin",
      pipelineDescription: "Generated by OpenScope",
      usage: "main",
      mode: "video",
      supportsPrompts: true,
      remoteInference: false,
    },
  },
  noteGuide: {
    label: "Note",
    config: {
      title: "Step 1",
      content: "1. Add instructions here.\n2. Edit in the properties panel.",
    },
  },
  lessonGettingStarted: {
    label: "Getting Started",
    config: {
      title: "1. Getting Started",
      content: `Welcome to OpenScope! 

OpenScope is a visual plugin builder for Daydream Scope that lets you create AI video processing pipelines without coding.

KEY CONCEPTS:
• Plugin Config - Defines your plugin's identity (name, ID, usage type)
• Inputs - Video, Text Prompts, or Image References  
• Pipelines - AI models fetched from Scope server
• Preprocessors - Modify input before main pipeline
• Postprocessors - Modify output after main pipeline

GETTING STARTED:
1. Create a Plugin Config node first
2. Choose your usage type (main/preprocessor/postprocessor)
3. Add input nodes based on your mode
4. Connect nodes by dragging from output to input handles
5. Toggle the code icon to see the Python code!

Press the Generate button in the header to create your plugin.`,
    },
  },
  lessonFirstProcessor: {
    label: "First Processor",
    config: {
      title: "2. Creating Your First Processor",
      content: `Let's create a simple processor! 

STEP 1: Set Usage
• In Plugin Config, set Usage to "preprocessor" or "postprocessor"

STEP 2: Add Video Input
• Expand Input category
• Drag "Video Input" to canvas

STEP 3: Add a Custom Processor
• Expand Pre-processor or Post-processor category
• Drag "Create New (Beta)" to canvas
• Describe what you want in chat mode, or write code directly

STEP 4: Connect Nodes
• Click the right handle of Video Input
• Drag to the left handle of your processor

STEP 5: Add Output
• Expand Output category
• Drag "Pipeline Output" to canvas
• Connect your processor to it

STEP 6: Generate!
• Click Generate to create your plugin

Congratulations! You've created your first processor!`,
    },
  },
  lessonNodeTypes: {
    label: "Node Types",
    config: {
      title: "3. Understanding Node Types",
      content: `Each node serves a purpose in your pipeline!

INPUT NODES:
• Video Input - Accepts video frames from camera/file
• Text Prompt - Text input with weight for AI models
• Image Input - Reference images for image-to-video
• Parameters - Key-value config for runtime

PIPELINE NODE:
• Fetches AI pipelines from your Scope server
• These are remote inference models
• Toggle code to see the Python implementation

PREPROCESSOR NODES:
• Process input before the main pipeline
• Use Scope server pipelines or create custom with AI

POSTPROCESSOR NODES:
• Process output after the main pipeline  
• Use Scope server pipelines or create custom with AI

OUTPUT NODES:
• Pipeline Output - Main AI result`,
    },
  },
  lessonPreprocessors: {
    label: "Preprocessors",
    config: {
      title: "4. Working with Preprocessors",
      content: `Preprocessors modify input before the main AI pipeline!

WHEN TO USE:
• You need to prepare input for AI models
• Add custom processing logic
• Transform video in specific ways

AVAILABLE OPTIONS:
• Use pipelines from your Scope server
• Create custom with AI - describe what you want in chat mode

CREATING CUSTOM:
• Use "Create New (Beta)" in Pre-processor category
• Write Python code in code mode
• Process frames before main pipeline

TIPS:
• Preprocessors run BEFORE the main pipeline
• Connect output to main pipeline input
• Can chain multiple preprocessors`,
    },
  },
  lessonPostprocessors: {
    label: "Postprocessors",
    config: {
      title: "5. Working with Postprocessors",
      content: `Postprocessors enhance or modify the AI output!

WHEN TO USE:
• After AI generation completes
• Add visual effects or transformations
• Process the final output

AVAILABLE OPTIONS:
• Use pipelines from your Scope server
• Create custom with AI - describe what you want in chat mode

CREATING CUSTOM:
• Use "Create New (Beta)" in Post-processor category
• Write Python code in code mode
• Process output frames

TIPS:
• Postprocessors run AFTER the main pipeline
• Can chain multiple postprocessors
• The order matters for best results`,
    },
  },
};

export const useGraphStore = create<GraphState>((set, get) => ({
  nodes: [],
  edges: [],
  selectedNode: null,

  addNode: (type: string, position: { x: number; y: number }, config?: Record<string, unknown>, options?: { selectNode?: boolean }) => {
    let defaults = nodeDefaults[type] || { label: type, config: {} };
    let labelOverride: string | undefined;
    
    if (type.startsWith("pipeline_")) {
      const pipelineId = type.replace("pipeline_", "");
      const usage = config?.usage as string | undefined;
      
      if (pipelineId === "customPreprocessor") {
        defaults = {
          label: "Preprocessor",
          config: { pipelineId: "my-preprocessor", isCustomPipeline: true, usage: "preprocessor" },
        };
      } else if (pipelineId === "customPostprocessor") {
        defaults = {
          label: "Postprocessor",
          config: { pipelineId: "my-postprocessor", isCustomPipeline: true, usage: "postprocessor" },
        };
      } else {
        let label = "Main Pipeline";
        if (usage === "preprocessor") {
          label = "Preprocessor";
        } else if (usage === "postprocessor") {
          label = "Postprocessor";
        }
        defaults = {
          label,
          config: { pipelineId, usage },
        };
      }
    }

    if ((type === "parameters" || type === "custom") && config?.createNewKind) {
      labelOverride = config.createNewKind === "preprocessor" ? "Preprocessor" : "Postprocessor";
    }
    
    const newNode: Node<NodeData> = {
      id: uuidv4(),
      type: "scopeNode",
      position,
      selected: options?.selectNode !== false,
      data: {
        label: labelOverride || defaults.label || type,
        type,
        config: { ...defaults.config, ...config },
      },
    };
    
    if (options?.selectNode === false) {
      set({ nodes: [...get().nodes, newNode] });
    } else {
      set({ nodes: [...get().nodes, newNode], selectedNode: newNode.id });
    }
  },

  addNodesWithEdges: (nodes, edges) => {
    const NODE_WIDTH = 280;
    const NODE_HEIGHT = 150;
    const HORIZONTAL_GAP = 100;
    const VERTICAL_GAP = 80;

    const needsLayout = nodes.some(n => !n.position || n.position.x < 200);

    const newNodes: Node<NodeData>[] = nodes.map((n, index) => {
      const defaults = nodeDefaults[n.type] || { label: n.type, config: {} };
      
      let position = n.position;
      if (needsLayout && n.position) {
        position = {
          x: 50 + index * (NODE_WIDTH + HORIZONTAL_GAP),
          y: 50 + Math.floor(index / 3) * (NODE_HEIGHT + VERTICAL_GAP),
        };
      }

      let config = { ...defaults.config, ...n.config };
      if (n.type.startsWith("pipeline_")) {
        const pipelineId = n.type.replace("pipeline_", "");
        config = { ...config, pipelineId };
      }

      return {
        id: uuidv4(),
        type: "scopeNode",
        position,
        selected: false,
        data: {
          label: defaults.label || n.type,
          type: n.type,
          config,
        },
      };
    });

    let newEdges: Edge[] = [];
    
    const isInputNode = (type: string) => 
      ["videoInput", "textPrompt", "imageInput", "parameters"].includes(type);
    const isOutputNode = (type: string) => 
      type === "pipelineOutput";
    const isPipelineNode = (type: string) => 
      type.startsWith("pipeline_") || type === "pipeline";
    
    if (edges && edges.length > 0) {
      newEdges = edges.map((e) => ({
        id: uuidv4(),
        source: newNodes[e.source]?.id,
        target: newNodes[e.target]?.id,
        type: "smoothstep",
        animated: true,
      }));
    } else if (newNodes.length > 1) {
      const pluginConfig = newNodes.find(n => n.data.type === "pluginConfig");
      const inputNodes = newNodes.filter(n => isInputNode(n.data.type));
      const pipelineNodes = newNodes.filter(n => isPipelineNode(n.data.type));
      const outputNodes = newNodes.filter(n => isOutputNode(n.data.type));

      let colIndex = 0;
      
      if (pluginConfig) {
        pluginConfig.position = { x: 50, y: 50 + colIndex * (NODE_HEIGHT + VERTICAL_GAP) };
        colIndex++;
      }

      inputNodes.forEach(node => {
        node.position = { x: 50 + (NODE_WIDTH + HORIZONTAL_GAP), y: 50 + colIndex * (NODE_HEIGHT + VERTICAL_GAP) };
        if (pluginConfig) {
          newEdges.push({
            id: uuidv4(),
            source: pluginConfig.id,
            target: node.id,
            type: "smoothstep",
            animated: true,
          });
        }
        colIndex++;
      });

      pipelineNodes.forEach(node => {
        node.position = { x: 50 + 2 * (NODE_WIDTH + HORIZONTAL_GAP), y: 50 + colIndex * (NODE_HEIGHT + VERTICAL_GAP) };
        const firstInput = inputNodes[0] || pluginConfig;
        if (firstInput) {
          newEdges.push({
            id: uuidv4(),
            source: firstInput.id,
            target: node.id,
            type: "smoothstep",
            animated: true,
          });
        }
        colIndex++;
      });

      outputNodes.forEach(node => {
        node.position = { x: 50 + 3 * (NODE_WIDTH + HORIZONTAL_GAP), y: 50 };
        pipelineNodes.forEach(pipeline => {
          newEdges.push({
            id: uuidv4(),
            source: pipeline.id,
            target: node.id,
            type: "smoothstep",
            animated: true,
          });
        });
      });
    }

    const pluginConfigNode = newNodes.find(n => n.data.type === "pluginConfig");
    const selectedId = pluginConfigNode?.id || newNodes[0]?.id;

    set({
      nodes: [...get().nodes, ...newNodes],
      edges: [...get().edges, ...newEdges],
      selectedNode: selectedId,
    });
  },

  updateNodeConfig: (nodeId: string, config: Record<string, unknown>) => {
    set({
      nodes: get().nodes.map((node) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, config: { ...node.data.config, ...config } } }
          : node
      ),
    });
  },

  updateNodeType: (nodeId: string, type: string, config?: Record<string, unknown>) => {
    set({
      nodes: get().nodes.map((node) => {
        if (node.id !== nodeId) return node;
        const defaults = nodeDefaults[type] || { label: type, config: {} };
        return {
          ...node,
          data: {
            ...node.data,
            type,
            label: defaults.label || type,
            config: { ...(defaults.config || {}), ...(config || {}) },
          },
        };
      }),
    });
  },

  deleteNode: (nodeId: string) => {
    set({
      nodes: get().nodes.filter((node) => node.id !== nodeId),
      edges: get().edges.filter(
        (edge) => edge.source !== nodeId && edge.target !== nodeId
      ),
      selectedNode: get().selectedNode === nodeId ? null : get().selectedNode,
    });
  },

  selectNode: (nodeId: string | null) => {
    set({ selectedNode: nodeId });
  },

  clearAll: () => {
    set({ nodes: [], edges: [], selectedNode: null });
  },

  addOutputNode: () => {
    const { nodes, edges } = get();
    if (nodes.length === 0) return;

    const pluginConfig = nodes.find(n => n.data.type === "pluginConfig");
    const usage = (pluginConfig?.data?.config?.usage as string) || "main";

    let outputType = "pipelineOutput";

    let rightmostNode = nodes[0];
    let maxX = nodes[0].position.x;
    for (const node of nodes) {
      if (node.position.x > maxX) {
        maxX = node.position.x;
        rightmostNode = node;
      }
    }

    const outputDefaults = nodeDefaults[outputType] || { label: outputType, config: {} };
    const outputNode: Node<NodeData> = {
      id: uuidv4(),
      type: "scopeNode",
      position: { x: maxX + 200, y: rightmostNode.position.y },
      selected: true,
      data: {
        label: outputDefaults.label || outputType,
        type: outputType,
        config: outputDefaults.config || {},
      },
    };

    const newEdge: Edge = {
      id: uuidv4(),
      source: rightmostNode.id,
      target: outputNode.id,
      type: "smoothstep",
      animated: true,
    };

    set({
      nodes: [...nodes, outputNode],
      edges: [...edges, newEdge],
      selectedNode: outputNode.id,
    });
  },

  onNodesChange: (changes) => {
    set({ nodes: applyNodeChanges(changes, get().nodes) });
  },

  onEdgesChange: (changes) => {
    set({ edges: applyEdgeChanges(changes, get().edges) });
  },

  onConnect: (connection: Connection) => {
    set({ edges: addEdge({ ...connection, id: uuidv4() }, get().edges) });
  },
}));
